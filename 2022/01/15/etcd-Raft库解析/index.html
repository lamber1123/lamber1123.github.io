<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="msvalidate.01" content="D5358D241F26545F49E55D403F921D5D"><meta name="google-site-verification" content="7h0jWlXl61CeDREpTs47QhQ9Qz7CJptnpSUcrIxB_II"><meta name="baidu-site-verification" content="code-Ob43MMYNMI"><title>etcd Raft库解析 - Lamber&#039;s Blog: Lamber的个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lamber&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lamber&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="输入及输出 raft库代码结构及核心数据结构 节点状态 选举流程 集群成员变化流程 如何做到线性一致性"><meta property="og:type" content="blog"><meta property="og:title" content="etcd Raft库解析"><meta property="og:url" content="https://lameber1123.github.io/"><meta property="og:site_name" content="Lamber&#039;s Blog"><meta property="og:description" content="输入及输出 raft库代码结构及核心数据结构 节点状态 选举流程 集群成员变化流程 如何做到线性一致性"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/unstable.png"><meta property="og:image" content="https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/raftlog.png"><meta property="og:image" content="https://lameber1123.github.io/msgreadindex.png"><meta property="og:image" content="https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/next-match.png"><meta property="article:published_time" content="2022-01-15T15:06:42.000Z"><meta property="article:modified_time" content="2022-01-19T08:30:57.173Z"><meta property="article:author" content="Lamber"><meta property="article:tag" content="Raft"><meta property="article:tag" content="分布式"><meta property="article:tag" content="etcd"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/unstable.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://lameber1123.github.io"},"headline":"etcd Raft库解析","image":["https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/unstable.png","https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/raftlog.png","https://lameber1123.github.io/msgreadindex.png","https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/next-match.png"],"datePublished":"2022-01-15T15:06:42.000Z","dateModified":"2022-01-19T08:30:57.173Z","author":{"@type":"Person","name":"Lamber"},"publisher":{"@type":"Organization","name":"Lamber's Blog","logo":{"@type":"ImageObject","url":"https://lameber1123.github.io/img/logo.png"}},"description":"输入及输出 raft库代码结构及核心数据结构 节点状态 选举流程 集群成员变化流程 如何做到线性一致性"}</script><link rel="canonical" href="https://lameber1123.github.io/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/css/font.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?4edd89be4e1594bf8520dcaf7b48bcce";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script type="text/javascript" src="/js/clicklove.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Lamber&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/lamber1123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-15T15:06:42.000Z" title="2022/1/15 下午11:06:42">2022-01-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-19T08:30:57.173Z" title="2022/1/19 下午4:30:57">2022-01-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Raft%E7%AC%94%E8%AE%B0/">Raft笔记</a></span><span class="level-item">2 hours read (About 16440 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">etcd Raft库解析</h1><div class="content"><ul>
<li>输入及输出</li>
<li>raft库代码结构及核心数据结构</li>
<li>节点状态</li>
<li>选举流程</li>
<li>集群成员变化流程</li>
<li>如何做到线性一致性</li>
</ul>
<span id="more"></span>

<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p1">1. 简介</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p2">2. 输入及输出</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3">3. raft库代码结构及核心数据结构</a><ul>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_1">3.1 日志存储：unstable</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_2">3.2 日志存储：Storage接口</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_3">3.3 日志存储：raftLog的实现</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_4">3.4 Raft 消息结构体</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_5">3.5 MsgHup消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_6">3.6 MsgBeat消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_7">3.7 MsgProp消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_8">3.8 MsgApp和MsgSnap消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_9">3.9 MsgAppResp消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_10">3.10 MsgVote/MsgPreVote/MsgVoteResp/MsgPreVoteResp 消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_11">3.11 MsgHeartbeat/MsgHeartbeatResp消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_12">3.12 MsgUnreachable消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_13">3.13 MsgSnapStatus消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_14">3.14 MsgCheckQuorum消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_15">3.15 MsgTransferLeader消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_16">3.16 MsgTimeoutNow消息</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p3_17">3.17 MsgReadIndex和MsgReadIndexResp消息</a></li>
</ul>
</li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p4">4. 节点状态</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p5">5. 选举流程</a><ul>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p5_1">5.1 发起选举的节点</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p5_2">5.2 收到选举消息的节点</a></li>
</ul>
</li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p6">6. 集群成员变化流程</a><ul>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p6_1">6.1 一般的成员删减</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p6_2">6.2 leader 转让</a></li>
</ul>
</li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p7">7. 如何做到线性一致性</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p8">8. 其他</a><ul>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p8_1">8.1 节点的几种状态</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p8_2">8.2 Progress 上的数据索引</a></li>
<li><a href="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/#p8_3">8.3 流量控制</a></li>
</ul>
</li>
</ul>
<!--more-->

<hr>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a><p id="p1">1. 简介</p></h2><p>本文是继Raft算法原理</a>一文之后的第二篇笔记，是对etcd Raft算法库的学习笔记，依旧是在codedump的网络日志基础之上所作。之所以详细的学习etcd对Raft算法原理的实现，是因为etcd的Raft实现最接近论文且应用广泛。</p>
<p>etcd Raft库的实现非常精妙，屏蔽了网络、存储等模块，提供了接口由上层应用来实现。</p>
<p>这里先给出部分名词的对照：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>Term</td>
<td>选举任期，每次选举之后递增1</td>
</tr>
<tr>
<td>Vote</td>
<td>选举投票(的ID)</td>
</tr>
<tr>
<td>Entry</td>
<td>Raft算法的日志数据条目</td>
</tr>
<tr>
<td>leader</td>
<td>领导者</td>
</tr>
<tr>
<td>follower</td>
<td>跟随者</td>
</tr>
<tr>
<td>candidate</td>
<td>候选人</td>
</tr>
<tr>
<td>commit</td>
<td>提交</td>
</tr>
<tr>
<td>propose</td>
<td>提议</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-输入及输出"><a href="#2-输入及输出" class="headerlink" title="2. 输入及输出"></a><p id="p2">2. 输入及输出</p></h2><p>要想使用Raft库，就要确定它的输入和输出接口。作为一个一致性算法的库，不难想象使用的一般场景是这样的：</p>
<ol>
<li>应用层接收到新的写入数据请求，向该算法库写入一个数据。</li>
<li>算法库返回是否写入成功。</li>
<li>应用层根据写入结果进行下一步的操作。</li>
</ol>
<p>然而，Raft库却相对而言更复杂一些，因为还有下列问题存在：</p>
<ol>
<li>写入的数据，可能是集群状态变更的数据，Raft库在执行写入这类数据之后，需要返回新的状态给应用层。</li>
<li>Raft库中的数据不可能一直以日志的形式存在，这样会导致数据越来越大，所以有必要压缩成快照的数据形式，这种情况下也需要返回这部分快照数据。</li>
<li>由于etcd的Raft库不包括持久化数据存储相关的模块，而是由应用层自己来做实现，所以也需要返回在某次写入成功之后，哪些数据可以进行持久化保存了。</li>
<li>同样的，etcd的Raft库也不自己实现网络传输，所以同样需要返回哪些数据需要进行网络传输给集群中的其他节点。</li>
</ol>
<p>以上的这些内容，集中在raft/node.go的Ready结构体中，其包括以下成员：</p>
<table>
<thead>
<tr>
<th>成员名称</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SoftState</td>
<td>SoftState</td>
<td>软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态</td>
</tr>
<tr>
<td>HardState</td>
<td>HardState</td>
<td>硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit</td>
</tr>
<tr>
<td>ReadStates</td>
<td>[]ReadStates</td>
<td>用于读一致性的数据，后续会详细介绍</td>
</tr>
<tr>
<td>Entries</td>
<td>[]pb.Entry</td>
<td>在向其他集群发送消息之前需要先写入持久化存储的日志数据</td>
</tr>
<tr>
<td>Snapshot</td>
<td>pb.Snapshot</td>
<td>需要写入持久化存储中的快照数据</td>
</tr>
<tr>
<td>CommittedEntries</td>
<td>[]pb.Entry</td>
<td>需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了</td>
</tr>
<tr>
<td>Messages</td>
<td>[]pb.Message</td>
<td>在entries被写入持久化存储中以后，需要发送出去的数据</td>
</tr>
</tbody></table>
<p>根据上面的分析，应用层在写入一段数据之后，Raft库将返回这样一个Ready结构体，其中可能某些字段是空的，毕竟不是每次改动都会导致Ready结构体中的成员都发生变化，此时使用者就需要根据情况，取出其中不为空的成员进行操作。</p>
<p>在etcd项目中，也提供了使用Raft库的demo例子，在 contrib/raftexample 目录中，这里简单的演示了一下如何根据这个raft库实现一个简单的KV存储服务器，下面将根据代码结合着上面的Ready结构体，来分析etcd Raft库的使用。</p>
<p>Raft库对外提供一个Node的interface，其实现有 raft/node.go 中的node结构体实现，这也是应用层唯一需要与Raft库直接打交道的结构体，简单的来看看Node接口需要实现的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Tick</td>
<td>应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等。至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了</td>
</tr>
<tr>
<td>Campaign</td>
<td>调用该函数将驱动节点进入候选人状态，进而将竞争leader</td>
</tr>
<tr>
<td>Propose</td>
<td>提议写入数据到日志中，可能会返回错误</td>
</tr>
<tr>
<td>ProposeConfChange</td>
<td>提交配置变更</td>
</tr>
<tr>
<td>Step</td>
<td>将消息msg灌入状态机中</td>
</tr>
<tr>
<td>Ready</td>
<td>这里是核心函数，将返回Ready的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作</td>
</tr>
<tr>
<td>Advance</td>
<td>Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作</td>
</tr>
</tbody></table>
<p>我们暂且只看如何对接Ready结构体，在raftexample中，首先在main.go中创建了两个channel：</p>
<ul>
<li>proposeC：用于提交写入的数据</li>
<li>confChangeC：用于提交配置改动数据</li>
</ul>
<p>然后分别启动如下核心的协程：</p>
<ul>
<li>启动HTTP服务器，用于接收用户的请求数据，最终会将用户请求的数据写入前面的 proposeC/confChangeC channel 中。</li>
<li>启动raftNode结构体，该结构体中有上面提到的 raft/node.go 中的node结构体，也就是通过该结构体实现的Node接口与raft库进行交互。同时，raftNode还会启动协程监听前面的两个channel，收到数据之后通过Node接口的函数调用raft库对应的接口。</li>
</ul>
<p>总结一下上面的交互流程：HTTP服务器负责接收用户数据，再写入到两个核心channel中，而raftNode负责监听这两个channel。</p>
<ul>
<li>如果收到 proposeC channel 的消息，说明有数据提交，则调用Node.Propose函数进行数据的提交。</li>
<li>如果收到 confChangeC channel 的消息，说明有配置变更，则调用 Node.ProposeConfChange 函数进行配置变更。</li>
<li>设置一个定时器 tick，每次定时器到时时，调用 Node.Tick 函数。</li>
<li>监听 Node.Ready 函数返回的Ready结构体channel，有数据变更时根据Ready结构体的不同数据类型进行相应的操作，完成了之后需要调用Node.Advance函数进行收尾。</li>
</ul>
<p>将以上流程用伪代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// HTTP server</span><br><span class="line">HttpServer主循环:</span><br><span class="line">  接收用户提交的数据：</span><br><span class="line">    如果是PUT请求：</span><br><span class="line">      将数据写入到proposeC中</span><br><span class="line">    如果是POST请求：</span><br><span class="line">      将配置变更数据写入到confChangeC中</span><br><span class="line">// raft Node</span><br><span class="line">raftNode结构体主循环：</span><br><span class="line">  如果proposeC中有数据写入：</span><br><span class="line">    调用 node.Propose 向raft库提交数据</span><br><span class="line">  如果confChangeC中有数据写入：</span><br><span class="line">    调用 node.Node.ProposeConfChange 向raft库提交配置变更数据</span><br><span class="line">  如果tick定时器到期：</span><br><span class="line">    调用 node.Tick 函数进行raft库的定时操作</span><br><span class="line">  如果 node.Ready() 函数返回的Ready结构体channel有数据变更：</span><br><span class="line">    依次处理Ready结构体中各成员数据</span><br><span class="line">    处理完毕之后调用node.Advance函数进行收尾处理</span><br></pre></td></tr></table></figure>

<p>看到这里，对raft的使用应该有了一个基本的概念，即通过node结构体实现的Node接口与raft库进行交互，涉及数据变更的核心数据结构就是Ready结构体，接下来可以进一步来分析该库的实现了。</p>
<hr>
<h2 id="3-raft库代码结构及核心数据结构"><a href="#3-raft库代码结构及核心数据结构" class="headerlink" title="3. raft库代码结构及核心数据结构"></a><p id="p3">3. raft库代码结构及核心数据结构</p></h2><p>在这一部分，来看下raft库的代码组织。</p>
<p>前面输入输出部分已经看到 raft/node.go 文件中，提供出去的是Node接口及其实现node结构体，这是外界与raft库交互的唯一接口，除此之外该路径下的其他文件并不直接与外界交互。</p>
<p>接着是raft算法的实现文件，raft/raft.go 文件，其中包含两个核心数据结构：</p>
<ul>
<li>Config：与raft算法相关的配置参数都包装在该结构体中。从这个结构体的命名是大写字母开头，就可以知道是提供给外部调用的。</li>
<li>raft：具体实现raft算法的结构体。</li>
</ul>
<p>除去上面两个文件，raft目录下的其他文件，都是间接给raft结构体服务的，下面的表格做一个总结和罗列：</p>
<table>
<thead>
<tr>
<th>结构体/接口</th>
<th>所在文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Node接口</td>
<td>node.go</td>
<td>提供raft库与外界交互的接口</td>
</tr>
<tr>
<td>node</td>
<td>node.go</td>
<td>实现Node接口</td>
</tr>
<tr>
<td>Config</td>
<td>raft.go</td>
<td>封装raft算法相关配置参数</td>
</tr>
<tr>
<td>raft</td>
<td>raft.go</td>
<td>raft算法的实现</td>
</tr>
<tr>
<td>ReadState</td>
<td>read_only.go</td>
<td>线性一致性读相关</td>
</tr>
<tr>
<td>readOnly</td>
<td>read_only.go</td>
<td>线性一致性读相关</td>
</tr>
<tr>
<td>raftLog</td>
<td>log.go</td>
<td>实现raft日志操作</td>
</tr>
<tr>
<td>Progress</td>
<td>progress.go</td>
<td>该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志</td>
</tr>
<tr>
<td>Storage接口</td>
<td>storage.go</td>
<td>提供存储接口，应用层可以按照自己的需求实现该接口</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-1-日志存储：unstable"><a href="#3-1-日志存储：unstable" class="headerlink" title="3.1 日志存储：unstable"></a><p id="p3_1">3.1 日志存储：unstable</p></h3><p>顾名思义，unstable数据结构用于还没有被用户层持久化的数据，而其中又包括两部分，如下图所示：</p>
<p><img src="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/unstable.png" alt="unstable"></p>
<p>如图，前半部分是快照数据，而后半部分是日志条目组成的数组entries，另外 unstable.offset 成员保存的是entries数组中的第一条数据在raft日志中的索引，即第i条entries数组数据在raft日志中的索引为i + unstable.offset。</p>
<p>这两个部分，并不同时存在，同一时间只有一个部分存在。其中，快照数据只有当前节点在接收从leader发送过来的快照数据时存在，在接收快照数据的时候，entries数组中是没有数据的；除了这种情况之外，就只会存在entries数组的数据了。因此，当接收完毕快照数据进入正常的接收日志流程时，快照数据将被置空。</p>
<p>理解了以上unstable中数据的分布情况，就不难理解unstable各个函数成员的作用了：</p>
<ul>
<li>maybeFirstIndex：返回unstable数据的第一条数据索引。因为只有快照数据在最前面，因此这个函数只有当快照数据存在的时候才能拿到第一条数据索引，其他的情况下已经拿不到了。</li>
<li>maybeLastIndex：返回最后一条数据的索引。因为是entries数据在后，而快照数据在前，所以取最后一条数据索引是从entries开始查，查不到的情况下才查快照数据。</li>
<li>maybeTerm：这个函数根据传入的日志数据索引，得到这个日志对应的任期号。前面已经提过，unstable.offset是快照数据和entries数组的分界线，因为在这个函数中，会区分传入的参数与offset的大小关系，小于offset的情况下在快照数据中查询，否则就在entries数组中查询了。</li>
<li>stableTo：该函数传入一个索引号i和任期号t，表示应用层已经将这个索引之前的数据进行持久化了，此时unstable要做的事情就是在自己的数据中查询，只有在满足任期号相同以及i大于等于offset的情况下，可以将entries中的数据进行缩容，将i之前的数据删除。</li>
<li>stableSnapTo：该函数传入一个索引i，用于告诉unstable，索引i对应的快照数据已经被应用层持久化了，如果这个索引与当前快照数据对应的上，那么快照数据就可以被置空了。</li>
<li>restore：从快照数据中恢复，此时unstable将保存快照数据，同时将offset成员设置成这个快照数据索引的下一位。</li>
<li>truncateAndAppend：传入日志条目数组，这段数据将添加到entries数组中。但是需要注意的是，传入的数据跟现有的entries数据可能有重合的部分，所以需要根据unstable.offset与传入数据的索引大小关系进行处理，有些数据可能会被截断。</li>
<li>slice：返回索引范围在[lo-u.offset : hi-u.offset]之间的数据。</li>
<li>mustCheckOutOfBounds：检查传入的数据索引范围是否合理。</li>
</ul>
<hr>
<h3 id="3-2-日志存储：Storage接口"><a href="#3-2-日志存储：Storage接口" class="headerlink" title="3.2 日志存储：Storage接口"></a><p id="p3_2">3.2 日志存储：Storage接口</p></h3><p>Storage接口，提供了存储持久化日志相关的接口操作.</p>
<ul>
<li>InitialState() (pb.HardState, pb.ConfState, error)：返回当前的初始状态，其中包括硬状态（HardState）以及配置（里面存储了集群中有哪些节点）。</li>
<li>Entries(lo, hi, maxSize uint64) ([]pb.Entry, error)：传入起始和结束索引值，以及最大的尺寸，返回索引范围在这个传入范围以内并且不超过大小的日志条目数组。</li>
<li>Term(i uint64) (uint64, error)：传入日志索引i，返回这条日志对应的任期号。找不到的情况下error返回值不为空，其中当返回ErrCompacted表示传入的索引数据已经找不到，说明已经被压缩成快照数据了；返回ErrUnavailable：表示传入的索引值大于当前的最大索引。</li>
<li>LastIndex() (uint64, error)：返回最后一条数据的索引。</li>
<li>FirstIndex() (uint64, error)：返回第一条数据的索引。</li>
<li>Snapshot() (pb.Snapshot, error)：返回最近的快照数据。</li>
</ul>
<p>codedump对这个接口提供的接口函数存有疑问，因为在所有etcd代码中，该接口只有MemoryStorage一个实现，而实际上MemoryStorage这个结构体还有其他的函数，比如添加日志数据的操作，但是这个操作并没有在Storage接口中声明。而Storage接口的 MemoryStorage 结构体的实现，其成员主要包括以下几个部分：</p>
<ul>
<li>hardState pb.HardState：存储硬状态。</li>
<li>snapshot pb.Snapshot：存储快照数据。</li>
<li>ents []pb.Entry：存储紧跟着快照数据的日志条目数组，即ents[i]保存的日志数据索引位置为i + snapshot.Metadata.Index。</li>
</ul>
<hr>
<h3 id="3-3-日志存储：raftLog的实现"><a href="#3-3-日志存储：raftLog的实现" class="headerlink" title="3.3 日志存储：raftLog的实现"></a><p id="p3_3">3.3 日志存储：raftLog的实现</p></h3><p>在unstable、Storage的基础上，我们来看一下raftLog的实现，这个结构体承担了raft日志相关的操作，它由一下成员组成：</p>
<ul>
<li>storage Storage：前面提到的存放已经持久化数据的Storage接口。</li>
<li>unstable unstable：前面分析过的unstable结构体，用于保存应用层还没有持久化的数据。</li>
<li>committed uint64：保存当前提交的日志数据索引。</li>
<li>applied uint64：保存当前传入状态机的数据最高索引。</li>
</ul>
<p>在Raft算法原理中也提到过，一条日志数据，首先需要先被提交（committed）成功，才能被应用（applied）到状态机中。因此，以下不等式一直成立：applied &lt;= committed。</p>
<p>raftLog结构体中，几部分数据的排列如下图所示：</p>
<p><img src="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/raftlog.png" alt="raftlog"></p>
<p>这个数据排布的情况，可以从raftLog的初始化函数中看出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLog</span><span class="params">(storage Storage, logger Logger)</span> *<span class="title">raftLog</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> storage == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(<span class="string">&quot;storage must not be nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log := &amp;raftLog&#123;</span><br><span class="line">		storage: storage,</span><br><span class="line">		logger:  logger,</span><br><span class="line">	&#125;</span><br><span class="line">	firstIndex, err := storage.FirstIndex()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err) <span class="comment">// TODO(bdarnell)</span></span><br><span class="line">	&#125;</span><br><span class="line">	lastIndex, err := storage.LastIndex()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err) <span class="comment">// TODO(bdarnell)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// offset从持久化之后的最后一个index的下一个开始</span></span><br><span class="line">	log.unstable.offset = lastIndex + <span class="number">1</span></span><br><span class="line">	log.unstable.logger = logger</span><br><span class="line">	<span class="comment">// Initialize our committed and applied pointers to the time of the last compaction.</span></span><br><span class="line">	<span class="comment">// committed和applied从持久化的第一个index的前一个开始</span></span><br><span class="line">	log.committed = firstIndex - <span class="number">1</span></span><br><span class="line">	log.applied = firstIndex - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里：</p>
<ul>
<li>firstIndex：该值取自storage.FirstIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的第一个数据索引，也就是MemoryStorage结构体中快照数据与日志条目数据的分界线。</li>
<li>lastIndex：该值取自storage.LastIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的最后一个数据索引。</li>
<li>unstable.offset：该值为lastIndex索引的下一个位置。</li>
<li>committed、applied：在初始的情况下，这两个值是firstIndex的上一个索引位置，这是因为在firstIndex之前的数据既然已经是持久化数据了，说明都是已经被提交成功的数据了。</li>
</ul>
<p>因此，从这里的代码分析可以看出，raftLog的两部分，持久化存储和非持久化存储，它们之间的分界线就是lastIndex，在此之前都是Storage管理的已经持久化的数据，而在此之后都是unstable管理的还没有持久化的数据。</p>
<p>以上分析中还有一个疑问，为什么并没有初始化unstable.snapshot成员，即unstable结构体的快照数据？这是因为，上面这个是初始化函数，也就是节点刚启动的时候调用来初始化存储状态的函数，而 unstable.snapshot 数据，是在启动之后同步数据的过程中，如果需要同步快照数据时才会去进行赋值修改的数据，因此在这里并不需要对其操作。</p>
<hr>
<h3 id="3-4-Raft-消息结构体"><a href="#3-4-Raft-消息结构体" class="headerlink" title="3.4 Raft 消息结构体"></a><p id="p3_4">3.4 Raft 消息结构体</p></h3><p>大体而言，raft算法本质上是一个大的状态机，任何的操作例如选举、提交数据等，最后的操作一定是封装成一个消息结构体，输入到raft算法库的状态机中。</p>
<p>在raft/raftpb/raft.proto文件中，定义了raft算法中传输消息的结构体。熟悉raft论文的都知道，raft算法其实由好几个协议组成，但是在这里，统一定义在了Message这个结构体之中，以下总结了该结构体的成员用途。</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MessageType</td>
<td>消息类型</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>消息发送者的节点ID</td>
</tr>
<tr>
<td>term</td>
<td>uint64</td>
<td>任期ID</td>
</tr>
<tr>
<td>logTerm</td>
<td>uint64</td>
<td>日志所处的任期ID</td>
</tr>
<tr>
<td>index</td>
<td>uint64</td>
<td>日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID</td>
</tr>
<tr>
<td>entries</td>
<td>Entry</td>
<td>日志条目数组</td>
</tr>
<tr>
<td>commit</td>
<td>uint64</td>
<td>提交日志索引</td>
</tr>
<tr>
<td>snapshot</td>
<td>Snapshot</td>
<td>快照数据</td>
</tr>
<tr>
<td>reject</td>
<td>bool    是否拒绝</td>
<td></td>
</tr>
<tr>
<td>rejectHint</td>
<td>uint64</td>
<td>拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置</td>
</tr>
<tr>
<td>context</td>
<td>bytes</td>
<td>上下文数据</td>
</tr>
</tbody></table>
<p>由于这个Message结构体，全部将raft协议相关的数据都定义在了一起，有些协议不是用到其中的全部数据，所以这里的字段都是可选的，codedump认为这样不好，这会看起来杂乱无章，所以有必要将每个协议（即不同的消息类型）中使用的用途分别记录。</p>
<hr>
<h3 id="3-5-MsgHup消息"><a href="#3-5-MsgHup消息" class="headerlink" title="3.5 MsgHup消息"></a><p id="p3_5">3.5 MsgHup消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgHup</td>
<td>不用于节点间通信，仅用于发送给节点让节点进行选举</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-6-MsgBeat消息"><a href="#3-6-MsgBeat消息" class="headerlink" title="3.6 MsgBeat消息"></a><p id="p3_6">3.6 MsgBeat消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgBeat</td>
<td>仅用于leader节点在heartbeat定时器到期时向集群中其他节点发送心跳消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-7-MsgProp消息"><a href="#3-7-MsgProp消息" class="headerlink" title="3.7 MsgProp消息"></a><p id="p3_7">3.7 MsgProp消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgProp</td>
<td>raft库使用者提议（propose）数据</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>entries</td>
<td>Entry</td>
<td>日志条目数组</td>
</tr>
</tbody></table>
<p>raft库的使用者向raft库propose数据时，最后会封装成这个类型的消息来进行提交，不同类型的节点处理不同:</p>
<h4 id="candidate"><a href="#candidate" class="headerlink" title="candidate"></a>candidate</h4><p>由于candidate节点没有处理propose数据的责任，直接忽略这类消息。</p>
<h4 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h4><p>首先检查集群内是否有leader存在，如果当前没有leader存在，说明还在选举过程中，直接忽略这类消息；否则转发给leader处理。</p>
<h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h4><p>leader对MsgProp消息的处理如下：</p>
<ol>
<li>检查entries数组是否没有数据，这是一个保护性检查。</li>
<li>检查本节点是否还在集群之中，如果已经不在了则直接返回不进行下一步处理。什么情况下会出现一个leader节点发现自己不存在集群之中了？这在Raft算法原理中提到过，这种情况出现在本节点已经通过配置变化被移除出了集群的场景。</li>
<li>检查 raft.leadTransferee 字段，当这个字段不为0时说明正在进行leader迁移操作，这种情况下不允许提交数据变更操作，因此此时也是直接返回的。</li>
<li>检查消息的entries数组，看其中是否带有配置变更的数据。如果其中带有数据变更而 raft.pendingConf为true，说明当前有未提交的配置更操作数据，根据raft论文，每次不同同时进行一次以上的配置变更，因此这里会将entries数组中的配置变更数据置为空数据。</li>
<li>到了这里可以进行真正的数据propose操作了，将调用raft算法库的日志模块写入数据，根据返回的情况向其他节点广播消息。</li>
</ol>
<hr>
<h3 id="3-8-MsgApp和MsgSnap消息"><a href="#3-8-MsgApp和MsgSnap消息" class="headerlink" title="3.8 MsgApp和MsgSnap消息"></a><p id="p3_8">3.8 MsgApp和MsgSnap消息</p></h3><h4 id="MsgApp消息"><a href="#MsgApp消息" class="headerlink" title="MsgApp消息"></a>MsgApp消息</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgApp</td>
<td>用于leader向集群中其他节点同步数据的消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>entries</td>
<td>Entry</td>
<td>日志条目数组</td>
</tr>
<tr>
<td>logTerm</td>
<td>uint64</td>
<td>日志所处的任期ID</td>
</tr>
<tr>
<td>index</td>
<td>uint64</td>
<td>索引ID</td>
</tr>
</tbody></table>
<h4 id="MsgSnap消息"><a href="#MsgSnap消息" class="headerlink" title="MsgSnap消息"></a>MsgSnap消息</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgSnap</td>
<td>用于leader向follower同步数据用的快照消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>snapshot</td>
<td>Snapshot</td>
<td>快照数据</td>
</tr>
</tbody></table>
<p>如果说前面的MsgProp消息是集群中的节点向leader转发用户提交的数据，那么MsgApp消息就是相反的，是leader节点用于向集群中其他节点同步数据的。</p>
<p>之所以把MsgSnap消息和MsgApp消息放在一起，是因为MsgSnap消息做的事情其实跟前面提到的MsgApp消息是一样的：都是用于leader向follower同步数据。实际上对于leader而言，向某个节点同步数据这个操作，都封装在 raft.sendAppend 函数中，至于具体用的哪种消息类型由这个函数内部实现。</p>
<p>什么情况下会用到快照数据来同步呢？raft算法中，任何的数据要提交成功，首先leader会在本地写一份日志，再广播出去给集群的其他节点，只有在超过半数以上的节点同意，leader才能进行提交操作。</p>
<p>但是，日志文件不能无限的增长。因此某些时刻，节点会将日志数据进行压缩处理，即把数据写入一个快照文件中。而leader在向某一个节点进行数据同步时，是根据该节点上的日志记录进行数据同步的。例如，leader上有最大索引为10的日志数据，而节点A的日志索引是2，那么leader将从3开始向节点A同步数据。</p>
<p>如果前面的数据已经进行了压缩处理，转换成了快照数据，而压缩后的快照数据实际上已经没有日志索引相关的信息了，这时只能将快照数据全部同步给节点。假如leader上日志索引为7之前的数据都已经被压缩成了快照数据，那么这部分数据在同步时是需要整份传输过去的，只有当同步完成节点赶上了leader上的日志进度时，才开始正常的日志同步流程。而同步数据时，需要区分两种情况。</p>
<hr>
<h3 id="3-9-MsgAppResp消息"><a href="#3-9-MsgAppResp消息" class="headerlink" title="3.9 MsgAppResp消息"></a><p id="p3_9">3.9 MsgAppResp消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgAppResp</td>
<td>集群中其他节点针对leader的MsgApp/MsgSnap消息的应答消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>index</td>
<td>uint64</td>
<td>日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID</td>
</tr>
<tr>
<td>reject</td>
<td>bool</td>
<td>是否拒绝同步日志的请求</td>
</tr>
<tr>
<td>rejectHint</td>
<td>uint64</td>
<td>拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置</td>
</tr>
</tbody></table>
<p>在节点收到leader的 MsgApp/MsgSnap 消息时，可能出现leader上的数据与自身节点数据不一致的情况，这种情况下会返回reject为true的MsgAppResp消息，同时rejectHint字段是本节点raft最后一条日志的索引ID。</p>
<p>index字段则返回的是当前节点的日志索引ID，用于向leader汇报自己已经commit的日志数据ID，这样leader就知道下一次同步数据给这个节点时，从哪条日志数据继续同步了。</p>
<p>leader节点在收到MsgAppResp消息的处理流程大体如下（stepLeader 函数中 MsgAppResp case 的处理流程）。</p>
<ul>
<li>首先，收到节点的MsgAppResp消息，说明该节点是活跃的，因此保存节点状态的RecentActive成员置为true。</li>
<li>接下来，再根据msg.Reject的返回值，即节点是否拒绝了这次数据同步，来区分两种情况进行处理：</li>
</ul>
<h4 id="msg-Reject-等于-true-的情况"><a href="#msg-Reject-等于-true-的情况" class="headerlink" title="msg.Reject 等于 true 的情况"></a>msg.Reject 等于 true 的情况</h4><p>如果msg.Reject为true，说明节点拒绝了前面的 MsgApp/MsgSnap 消息，根据 msg.RejectHint 成员回退leader上保存的关于该节点的日志记录状态。比如leader前面认为从日志索引为10的位置开始向节点A同步数据，但是节点A拒绝了这次数据同步，同时返回RejectHint为2，说明节点A告知leader在它上面保存的最大日志索引ID为2，这样下一次leader就可以直接从索引为2的日志数据开始同步数据到节点A。而如果没有这个RejectHint成员，leader只能在每次被拒绝数据同步后都递减1进行下一次数据同步，显然这样是低效的。</p>
<ul>
<li>因为上面节点拒绝了这次数据同步，所以节点的状态可能存在一些异常，此时如果leader上保存的节点状态为 ProgressStateReplicate，那么将切换到 ProgressStateProbe 状态。</li>
<li>前面已经按照 msg.RejectHint 修改了leader上关于该节点日志状态的索引数据，接着再次尝试按照这个新的索引数据向该节点再次同步数据。</li>
</ul>
<h4 id="msg-Reject-等于-false-的情况"><a href="#msg-Reject-等于-false-的情况" class="headerlink" title="msg.Reject 等于 false 的情况"></a>msg.Reject 等于 false 的情况</h4><p>这种情况说明该节点通过了leader的数据同步请求，这种情况下根据 msg.Index 来判断在leader中保存的该节点日志数据索引是否发生了更新，如果发生了更新那么就说明这个节点通过了新的数据，这种情况下会做以下的几个操作。</p>
<ol>
<li>修改节点状态<ul>
<li>如果该节点之前在 ProgressStateProbe 状态，说明之前处于探测状态，此时可以切换到 ProgressStateReplicate，开始正常的接收leader的同步数据了。</li>
<li>如果之前处于 ProgressStateSnapshot 状态，即还在同步副本，说明节点之前可能落后leader数据比较多才采用了接收副本的状态。在节点落后leader数据很多的情况下，可能leader会多次通过snapshot同步数据给节点，而当  pr.Match &gt;= pr.PendingSnapshot 的时候，说明通过快照来同步数据的流程完成了，这时可以进入正常的接收同步数据状态了，这就是函数 Progress.needSnapshotAbort 要做的判断。</li>
<li>如果之前处于 ProgressStateReplicate 状态，此时可以修改leader关于这个节点的滑动窗口索引，释放掉这部分数据索引，好让节点可以接收新的数据了。</li>
</ul>
</li>
<li>判断是否有新的数据可以提交（commit）了。因为raft的提交数据的流程是这样的：首先节点将数据提议（propose）给leader，leader在将数据写入到自己的日志成功之后，再通过MsgApp把这些提议的数据广播给集群中的其他节点，在某一条日志数据收到超过半数（qurom）的节点同意之后，才认为是可以提交（commit）的。因此每次leader节点在收到一条MsgAppResp类型消息，同时msg.Reject又是false的情况下，都需要去检查当前有哪些日志是超过半数的节点同意的，再将这些可以提交（commit）的数据广播出去。而在没有数据可以提交的情况下，如果之前节点处于暂停状态，那么将继续向该节点同步数据。</li>
<li>最后还要做一个跟leader迁移相关的操作。如果该消息节点是准备迁移过去的新leader节点（raft.leadTransferee == msg.From），而且此时该节点上的Match索引已经跟旧的leader的日志最大索引一致，说明新旧节点的日志数据已经同步，可以正式进行集群leader迁移操作了。</li>
</ol>
<hr>
<h3 id="3-10-MsgVote-MsgPreVote-MsgVoteResp-MsgPreVoteResp-消息"><a href="#3-10-MsgVote-MsgPreVote-MsgVoteResp-MsgPreVoteResp-消息" class="headerlink" title="3.10 MsgVote/MsgPreVote/MsgVoteResp/MsgPreVoteResp 消息"></a><p id="p3_10">3.10 MsgVote/MsgPreVote/MsgVoteResp/MsgPreVoteResp 消息</p></h3><p>之所以把这四种消息放在一起了，是因为Vote和PreVote流程的请求和应答时传输的数据是相同的。</p>
<h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgVote/MsgPreVote</td>
<td>节点投票给自己以进行新一轮的选举</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>term</td>
<td>uint64</td>
<td>任期ID</td>
</tr>
<tr>
<td>index</td>
<td>uint64</td>
<td>日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID</td>
</tr>
<tr>
<td>logTerm</td>
<td>uint64</td>
<td>日志所处的任期ID</td>
</tr>
<tr>
<td>context</td>
<td>bytes</td>
<td>上下文数据</td>
</tr>
</tbody></table>
<h4 id="应答数据"><a href="#应答数据" class="headerlink" title="应答数据"></a>应答数据</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgVoteResp/MsgPreVoteResp</td>
<td>投票应答消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>reject</td>
<td>bool</td>
<td>是否拒绝</td>
</tr>
</tbody></table>
<p>节点调用 raft.campaign 函数进行投票给自己进行一次新的选举，其中的参数 CampaignType 有以下几种类型：</p>
<ol>
<li>campaignPreElection：对应PreVote的场景。</li>
<li>campaignElection：正常的选举场景。</li>
<li>campaignTransfer：由于leader迁移发生的选举。如果是这种类型的选举，那么 msg.Context 字段保存的是“CampaignTransfer”字符串，这种情况下会强制进行leader的迁移。</li>
</ol>
<p>MsgVote还需要带上几个与本节点日志相关的数据（Index、LogTerm），因为raft算法要求，一个节点要成为leader的一个必要条件之一就是这个节点上的日志数据是最新的。</p>
<h4 id="PreVote"><a href="#PreVote" class="headerlink" title="PreVote"></a>PreVote</h4><p>这里需要特别解释一下PreVote的场景。</p>
<p>考虑到一种情况：当出现网络分区的时候，A、B、C、D、E五个节点被划分成了两个网络分区，A、B、C组成的分区和D、E组成的分区，其中的D节点，如果在选举超时到来时，都没有收到来自leader节点A的消息（因为网络已经分区），那么D节点认为需要开始一次新的选举了。</p>
<p>正常的情况下，节点D应该把自己的任期号term递增1，然后发起一次新的选举。由于网络分区的存在，节点D肯定不会获得超过半数以上的的投票，因为A、B、C三个节点组成的分区不会收到它的消息，这会导致节点D不停的由于选举超时而开始一次新的选举，而每次选举又会递增任期号。</p>
<p>在网络分区还没恢复的情况下，这样做问题不大。但是当网络分区恢复时，由于节点D的任期号大于当前leader节点的任期号，这会导致集群进行一次新的选举，即使节点D肯定不会获得选举成功的情况下（因为节点D的日志落后当前集群太多，不能赢得选举成功）。</p>
<p>为了避免这种无意义的选举流程，节点可以有一种<font color="red">PreVote</font>的状态，在这种状态下，想要参与选举的节点会首先连接集群的其他节点，只有在超过半数以上的节点连接成功时，才能真正发起一次新的选举。</p>
<p>所以，在PreVote状态下发起选举时，并不会导致节点本身的任期号递增1，而只有在进行正常选举时才会将任期号加1进行选举。</p>
<h4 id="MsgVote-MsgPreVote的处理流程"><a href="#MsgVote-MsgPreVote的处理流程" class="headerlink" title="MsgVote/MsgPreVote的处理流程"></a>MsgVote/MsgPreVote的处理流程</h4><p>节点对于投票消息的处理有两处，但都在raft.Step函数中。</p>
<p>首先该函数会判断 msg.Term 是否大于本节点的Term，如果消息的任期号更大则说明是一次新的选举。这种情况下将根据 msg.Context 是否等于“CampaignTransfer”字符串来确定是不是一次由于leader迁移导致的强制选举过程。同时也会根据当前的 electionElapsed 是否小于 electionTimeout 来确定是否还在租约期以内。如果既不是强制leader选举又在租约期以内，那么节点将忽略该消息的处理，这是为了避免已经离开集群的节点仍然频繁向集群内节点发起无意义的选举。如果以上检查流程通过了，说明可以进行选举了，如果消息类型还不是MsgPreVote类型，那么此时节点会切换到follower状态且认为发送消息过来的节点 msg.From 是新的leader。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">case</span> m.Term &gt; r.Term:</span><br><span class="line"><span class="comment">// 消息的Term大于节点当前的Term</span></span><br><span class="line">lead := m.From</span><br><span class="line"><span class="keyword">if</span> m.Type == pb.MsgVote || m.Type == pb.MsgPreVote &#123;</span><br><span class="line">	<span class="comment">// 如果收到的是投票类消息</span></span><br><span class="line">	<span class="comment">// 当context为campaignTransfer时表示强制要求进行竞选</span></span><br><span class="line">	force := bytes.Equal(m.Context, []<span class="keyword">byte</span>(campaignTransfer))</span><br><span class="line">	<span class="comment">// 是否在租约期以内</span></span><br><span class="line">	inLease := r.checkQuorum &amp;&amp; r.lead != None &amp;&amp; r.electionElapsed &lt; r.electionTimeout</span><br><span class="line">	<span class="keyword">if</span> !force &amp;&amp; inLease &#123;</span><br><span class="line">		<span class="comment">// 如果非强制，而且又在租约期以内，就不做任何处理</span></span><br><span class="line">		<span class="comment">// 非强制又在租约期内可以忽略选举消息，见论文的4.2.3，这是为了阻止已经离开集群的节点再次发起投票请求</span></span><br><span class="line">		<span class="comment">// If a server receives a RequestVote request within the minimum election timeout</span></span><br><span class="line">		<span class="comment">// of hearing from a current leader, it does not update its term or grant its vote</span></span><br><span class="line">		r.logger.Infof(<span class="string">&quot;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)&quot;</span>,</span><br><span class="line">			r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 否则将lead置为空</span></span><br><span class="line">	lead = None</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="comment">// 注意Go的switch case不做处理的话是不会默认走到default情况的</span></span><br><span class="line"><span class="keyword">case</span> m.Type == pb.MsgPreVote:</span><br><span class="line">	<span class="comment">// Never change our term in response to a PreVote</span></span><br><span class="line">	<span class="comment">// 在应答一个prevote消息时不对任期term做修改</span></span><br><span class="line"><span class="keyword">case</span> m.Type == pb.MsgPreVoteResp &amp;&amp; !m.Reject:</span><br><span class="line">	<span class="comment">// We send pre-vote requests with a term in our future. If the</span></span><br><span class="line">	<span class="comment">// pre-vote is granted, we will increment our term when we get a</span></span><br><span class="line">	<span class="comment">// quorum. If it is not, the term comes from the node that</span></span><br><span class="line">	<span class="comment">// rejected our vote so we should become a follower at the new</span></span><br><span class="line">	<span class="comment">// term.</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	r.logger.Infof(<span class="string">&quot;%x [term: %d] received a %s message with higher term from %x [term: %d]&quot;</span>,</span><br><span class="line">		r.id, r.Term, m.Type, m.From, m.Term)</span><br><span class="line">	<span class="comment">// 变成follower状态</span></span><br><span class="line">	r.becomeFollower(m.Term, lead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 raft.Step 函数的后面，会判断消息类型是MsgVote或者MsgPreVote来进一步进行处理。其判断条件是以下两个条件同时成立：</p>
<ul>
<li>当前没有给任何节点进行过投票（r.Vote == None ），或者消息的任期号更大（m.Term &gt; r.Term ），或者是之前已经投过票的节点（r.Vote == m.From)）。这个条件是检查是否可以还能给该节点投票。</li>
<li>同时该节点的日志数据必须是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm) ）。这个条件是检查这个节点上的日志数据是否足够的新。 只有在满足以上两个条件的情况下，节点才投票给这个消息节点，将修改raft.Vote为消息发送者ID。如果不满足条件，将应答msg.Reject=true，拒绝该节点的投票消息。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> pb.MsgVote, pb.MsgPreVote:</span><br><span class="line">	<span class="comment">// 收到投票类的消息</span></span><br><span class="line">	<span class="comment">// The m.Term &gt; r.Term clause is for MsgPreVote. For MsgVote m.Term should</span></span><br><span class="line">	<span class="comment">// always equal r.Term.</span></span><br><span class="line">	<span class="keyword">if</span> (r.Vote == None || m.Term &gt; r.Term || r.Vote == m.From) &amp;&amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) &#123;</span><br><span class="line">		<span class="comment">// 如果当前没有给任何节点投票（r.Vote == None）或者投票的节点term大于本节点的（m.Term &gt; r.Term）</span></span><br><span class="line">		<span class="comment">// 或者是之前已经投票的节点（r.Vote == m.From）</span></span><br><span class="line">		<span class="comment">// 同时还满足该节点的消息是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm)），那么就接收这个节点的投票</span></span><br><span class="line">		r.logger.Infof(<span class="string">&quot;%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d&quot;</span>,</span><br><span class="line">			r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)</span><br><span class="line">		r.send(pb.Message&#123;To: m.From, Type: voteRespMsgType(m.Type)&#125;)</span><br><span class="line">		<span class="keyword">if</span> m.Type == pb.MsgVote &#123;</span><br><span class="line">			<span class="comment">// Only record real votes.</span></span><br><span class="line">			<span class="comment">// 保存下来给哪个节点投票了</span></span><br><span class="line">			r.electionElapsed = <span class="number">0</span></span><br><span class="line">			r.Vote = m.From</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 否则拒绝投票</span></span><br><span class="line">		r.logger.Infof(<span class="string">&quot;%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d&quot;</span>,</span><br><span class="line">			r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)</span><br><span class="line">		r.send(pb.Message&#123;To: m.From, Type: voteRespMsgType(m.Type), Reject: <span class="literal">true</span>&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MsgVoteResp-MsgPreVoteResp的处理流程"><a href="#MsgVoteResp-MsgPreVoteResp的处理流程" class="headerlink" title="MsgVoteResp/MsgPreVoteResp的处理流程"></a>MsgVoteResp/MsgPreVoteResp的处理流程</h4><p>接下来看节点收到投票应答数据之后的处理。</p>
<p>节点调用 raft.poll 函数，其中传入 msg.Reject 参数表示发送者是否同意这次选举，根据这些来计算当前集群中有多少节点给这次选举投了同意票。<br>如果有半数的节点同意了，如果选举类型是PreVote，那么进行Vote状态正式进行一轮选举；否则该节点就成为了新的leader，调用 raft.becomeLeader 函数切换状态，然后开始同步日志数据给集群中其他节点了。<br>而如果半数以上的节点没有同意，那么重新切换到follower状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> myVoteRespType:</span><br><span class="line">	<span class="comment">// 计算当前集群中有多少节点给自己投了票</span></span><br><span class="line">	gr := r.poll(m.From, m.Type, !m.Reject)</span><br><span class="line">	r.logger.Infof(<span class="string">&quot;%x [quorum:%d] has received %d %s votes and %d vote rejections&quot;</span>, r.id, r.quorum(), gr, m.Type, <span class="built_in">len</span>(r.votes)-gr)</span><br><span class="line">	<span class="keyword">switch</span> r.quorum() &#123;</span><br><span class="line">	<span class="keyword">case</span> gr:	<span class="comment">// 如果进行投票的节点数量正好是半数以上节点数量</span></span><br><span class="line">		<span class="keyword">if</span> r.state == StatePreCandidate &#123;</span><br><span class="line">			r.campaign(campaignElection)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 变成leader</span></span><br><span class="line">			r.becomeLeader()</span><br><span class="line">			r.bcastAppend()</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(r.votes) - gr:	<span class="comment">// 如果是半数以上节点拒绝了投票</span></span><br><span class="line">		<span class="comment">// 变成follower</span></span><br><span class="line">		r.becomeFollower(r.Term, None)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-11-MsgHeartbeat-MsgHeartbeatResp消息"><a href="#3-11-MsgHeartbeat-MsgHeartbeatResp消息" class="headerlink" title="3.11 MsgHeartbeat/MsgHeartbeatResp消息"></a><p id="p3_11">3.11 MsgHeartbeat/MsgHeartbeatResp消息</p></h3><h4 id="心跳请求消息"><a href="#心跳请求消息" class="headerlink" title="心跳请求消息"></a>心跳请求消息</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgHeartbeat</td>
<td>用于leader向follower发送心跳消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>commit</td>
<td>uint64</td>
<td>提交日志索引</td>
</tr>
<tr>
<td>context</td>
<td>bytes</td>
<td>上下文数据，在这里保存一致性读相关的数据</td>
</tr>
</tbody></table>
<h4 id="心跳请求应答消息"><a href="#心跳请求应答消息" class="headerlink" title="心跳请求应答消息"></a>心跳请求应答消息</h4><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgHeartbeatResp</td>
<td>用于follower向leader应答心跳消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>本节点ID</td>
</tr>
<tr>
<td>context</td>
<td>bytes</td>
<td>上下文数据，在这里保存一致性读相关的数据</td>
</tr>
</tbody></table>
<p>leader中会定时向集群中其他节点发送心跳消息，该消息的作用除了探测节点的存活情况之外，还包括：</p>
<ul>
<li>commit成员：leader选择min(节点上的Match，leader日志最大提交索引)，用于告知节点哪些日志可以进行提交（commit）。</li>
<li>context：与线性一致性读相关，后文会做解释。</li>
</ul>
<hr>
<h3 id="3-12-MsgUnreachable消息"><a href="#3-12-MsgUnreachable消息" class="headerlink" title="3.12 MsgUnreachable消息"></a><p id="p3_12">3.12 MsgUnreachable消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgUnreachable</td>
<td>用于应用层向raft库汇报某个节点当前已不可达</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>不可用的节点ID</td>
</tr>
</tbody></table>
<p>仅leader才处理这类消息，leader如果判断该节点此时处于正常接收数据的状态（ProgressStateReplicate），那么就切换到探测状态。</p>
<hr>
<h3 id="3-13-MsgSnapStatus消息"><a href="#3-13-MsgSnapStatus消息" class="headerlink" title="3.13 MsgSnapStatus消息"></a><p id="p3_13">3.13 MsgSnapStatus消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgSnapStatus</td>
<td>用于应用层向raft库汇报某个节点当前接收快照状态</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>节点ID</td>
</tr>
<tr>
<td>reject</td>
<td>bool</td>
<td>是否拒绝</td>
</tr>
</tbody></table>
<p>仅leader处理这类消息：</p>
<ul>
<li>如果reject为false：表示接收快照成功，将切换该节点状态到探测状态。</li>
<li>否则接收失败。</li>
</ul>
<hr>
<h3 id="3-14-MsgCheckQuorum消息"><a href="#3-14-MsgCheckQuorum消息" class="headerlink" title="3.14 MsgCheckQuorum消息"></a><p id="p3_14">3.14 MsgCheckQuorum消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgCheckQuorum</td>
<td>用于leader检查集群可用性的消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>节点ID</td>
</tr>
</tbody></table>
<p>leader的定时器函数，在超过选举时间时，如果当前打开了 raft.checkQuorum 开关，那么leader将给自己发送一条 MsgCheckQuorum 消息，对该消息的处理是：检查集群中所有节点的状态，如果超过半数的节点都不活跃了，那么leader也切换到follower状态。</p>
<hr>
<h3 id="3-15-MsgTransferLeader消息"><a href="#3-15-MsgTransferLeader消息" class="headerlink" title="3.15 MsgTransferLeader消息"></a><p id="p3_15">3.15 MsgTransferLeader消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgTransferLeader</td>
<td>用于迁移leader</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>消息接收者的节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>新leader的节点ID</td>
</tr>
</tbody></table>
<p>这类消息由follower将转发给leader处理，因为follower并没有修改集群配置状态的权限。leader在收到这类消息时，是以下的处理流程：</p>
<ol>
<li>如果当前的 raft.leadTransferee 成员不为空，说明有正在进行的leader迁移流程。此时会判断是否与这次迁移是同样的新leader ID，如果是则忽略该消息直接返回；否则将<font color="red">终止</font>前面还没有完毕的迁移流程。</li>
<li>如果这次迁移过去的新节点，就是当前的leader ID，也直接返回不进行处理。</li>
<li>到了这一步就是正式开始这一次的迁移leader流程了，一个节点能成为一个集群的leader，其必要条件是上面的日志与当前leader的一样多，所以这里会判断是否满足这个条件，如果满足那么发送MsgTimeoutNow消息给新的leader通知该节点进行leader迁移，否则就先进行日志同步操作让新的leader追上旧leader的日志数据。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> pb.MsgTransferLeader:</span><br><span class="line">    leadTransferee := m.From</span><br><span class="line">    lastLeadTransferee := r.leadTransferee</span><br><span class="line">    <span class="keyword">if</span> lastLeadTransferee != None &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有相同节点的leader转让流程在进行中</span></span><br><span class="line">        <span class="keyword">if</span> lastLeadTransferee == leadTransferee &#123;</span><br><span class="line">            r.logger.Infof(<span class="string">&quot;%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x&quot;</span>,</span><br><span class="line">            r.id, r.Term, leadTransferee, leadTransferee)</span><br><span class="line">            <span class="comment">// 如果是，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则中断之前的转让流程</span></span><br><span class="line">        r.abortLeaderTransfer()</span><br><span class="line">        r.logger.Infof(<span class="string">&quot;%x [term %d] abort previous transferring leadership to %x&quot;</span>, r.id, r.Term, lastLeadTransferee)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否转让过来的leader是否本节点，如果是也直接返回，因为本节点已经是leader了</span></span><br><span class="line">    <span class="keyword">if</span> leadTransferee == r.id &#123;</span><br><span class="line">        r.logger.Debugf(<span class="string">&quot;%x is already leader. Ignored transferring leadership to self&quot;</span>, r.id)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer leadership to third party.</span></span><br><span class="line">    r.logger.Infof(<span class="string">&quot;%x [term %d] starts to transfer leadership to %x&quot;</span>, r.id, r.Term, leadTransferee)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.</span></span><br><span class="line">    r.electionElapsed = <span class="number">0</span></span><br><span class="line">    r.leadTransferee = leadTransferee</span><br><span class="line">    <span class="keyword">if</span> pr.Match == r.raftLog.lastIndex() &#123;</span><br><span class="line">        <span class="comment">// 如果日志已经匹配了，那么就发送timeoutnow协议过去</span></span><br><span class="line">        r.sendTimeoutNow(leadTransferee)</span><br><span class="line">        r.logger.Infof(<span class="string">&quot;%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log&quot;</span>, r.id, leadTransferee, leadTransferee)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则继续追加日志</span></span><br><span class="line">        r.sendAppend(leadTransferee)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-16-MsgTimeoutNow消息"><a href="#3-16-MsgTimeoutNow消息" class="headerlink" title="3.16 MsgTimeoutNow消息"></a><p id="p3_16">3.16 MsgTimeoutNow消息</p></h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgTimeoutNow</td>
<td>leader迁移时，当新旧leader的日志数据同步后，旧leader向新leader发送该消息通知可以进行迁移了</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>新的 leader ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>旧的 leader ID</td>
</tr>
</tbody></table>
<p>新的leader节点，在还未迁移之前仍然是follower，在收到这条消息后，就可以进行迁移了，此时会调用前面分析MsgVote时说过的campaign函数，传入的参数是 campaignTransfer，表示这是一次由于迁移leader导致的选举流程。</p>
<hr>
<h3 id="3-17-MsgReadIndex和MsgReadIndexResp消息"><a href="#3-17-MsgReadIndex和MsgReadIndexResp消息" class="headerlink" title="3.17 MsgReadIndex和MsgReadIndexResp消息"></a><p id="p3_17">3.17 MsgReadIndex和MsgReadIndexResp消息</p></h3><p>这两个消息一一对应，使用的成员也一样。</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>MsgReadIndex</td>
<td>用于读一致性的消息</td>
</tr>
<tr>
<td>to</td>
<td>uint64</td>
<td>接收者节点ID</td>
</tr>
<tr>
<td>from</td>
<td>uint64</td>
<td>发送者节点ID</td>
</tr>
<tr>
<td>entries</td>
<td>Entry</td>
<td>日志条目数组</td>
</tr>
</tbody></table>
<p>其中，entries数组只会有一条数据，带上的是应用层此次请求的标识数据，在follower收到MsgReadIndex消息进行应答时，同样需要把这个数据原样带回返回给leader，详细的线性读一致性的实现在后文展开分析。</p>
<hr>
<h2 id="4-节点状态"><a href="#4-节点状态" class="headerlink" title="4. 节点状态"></a><p id="p4">4. 节点状态</p></h2><p>每个raft的节点，分为以下三种状态：</p>
<ul>
<li>candidate：候选人状态，节点切换到这个状态时，意味着将进行一次新的选举。</li>
<li>follower：跟随者状态，节点切换到这个状态时，意味着选举结束。</li>
<li>leader：领导者状态，所有数据提交都必须先提交到leader上。</li>
</ul>
<p>每一个状态都有其对应的状态机，每次收到一条提交的数据时，都会根据其不同的状态将消息输入到不同状态的状态机中。同时，在进行tick操作时，每种状态对应的处理函数也不同。</p>
<p>所以raft结构体中将不同的状态，及其不同的处理函数独立出来几个成员变量：</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>state</td>
<td>保存当前节点状态</td>
</tr>
<tr>
<td>tick函数</td>
<td>tick函数，每个状态对应的tick函数不同</td>
</tr>
<tr>
<td>step函数</td>
<td>状态机函数，同样每个状态对应的状态机也不相同</td>
</tr>
</tbody></table>
<p>raft库中提供函数 becomeCandidate、becomeFollower、becomeLeader 分别进入这三种状态，这些函数中做的事情，概况起来就是：</p>
<ul>
<li>切换raft.state成员到对应状态。</li>
<li>切换raft.tick函数到对应状态的处理函数。</li>
<li>切换raft.step函数到对应状态的状态机。</li>
</ul>
<hr>
<h2 id="5-选举流程"><a href="#5-选举流程" class="headerlink" title="5. 选举流程"></a><p id="p5">5. 选举流程</p></h2><p>raft算法的第一步是首先选举出一个leader出来，在没有产生leader的情况下，其他数据提交等操作都无从谈起，所以先从选举的流程开始说起。</p>
<h3 id="5-1-发起选举的节点"><a href="#5-1-发起选举的节点" class="headerlink" title="5.1 发起选举的节点"></a><p id="p5_1">5.1 发起选举的节点</p></h3><p>只有在candidate或者follower状态下的节点，才有可能发起一个选举流程，而这两种状态的节点，其对应的tick函数都是raft.tickElection函数，这个函数的主要流程是：</p>
<ul>
<li>将选举超时递增1。</li>
<li>当选举超时到期，同时该节点又在集群中时，说明此时可以进行一轮新的选举。此时会向本节点发送HUP消息，这个消息最终会走到状态机函数raft.Step中进行处理。</li>
</ul>
<p>明白了raft.tickElection函数的作用，可以来看选举流程了：</p>
<ul>
<li>节点启动时都以follower状态启动，同时随机选择自己的选举超时时间，这是为了避免同时有两个节点同时进行选举，这种情况下会出现没有节点赢得半数以上投票从而这一轮选举失败，继续再进行下一轮选举。</li>
<li>在follower的tick函数 tickElection 函数中，当选举超时到时，节点向自己发送HUP消息。</li>
<li>在状态机函数 raft.Step 函数中，在收到HUP消息之后，节点首先判断当前有没有没有apply的配置变更消息，如果有就忽略该消息。其原因在于，当有配置更新的情况下不能进行选举操作，即要保证每一次集群成员变化时只能同时变化一个，不能同时有多个集群成员的状态发生变化。</li>
<li>否则进入 campaign 函数中进行选举：首先将任期号+1，然后广播给其他节点选举消息，带上的其它字段包括：节点当前的最后一条日志索引（Index字段），最后一条日志对应的任期号（LogTerm字段），选举任期号（Term字段，即前面已经进行+1之后的任期号），Context字段（目的是为了告知这一次是否是leader转让类需要强制进行选举的消息）。</li>
<li>如果在一个选举超时之内，该发起新的选举流程的节点，得到了超过半数的节点投票，那么状态就切换到leader状态，成为leader的同时，leader将发送一条dummy的append消息，目的是为了提交该节点上在此任期之前的值（见疑问部分如何提交之前任期的值）</li>
</ul>
<hr>
<h3 id="5-2-收到选举消息的节点"><a href="#5-2-收到选举消息的节点" class="headerlink" title="5.2 收到选举消息的节点"></a><p id="p5_2">5.2 收到选举消息的节点</p></h3><ul>
<li>当收到任期号大于当前节点任期号的消息，同时该消息类型如果是选举类的消息（类型为prevote或者vote）时，会做以下判断：<ol>
<li>首先会判断一下该消息是否为强制要求进行选举的类型（context为campaignTransfer，context为这种类型时表示在进行leader转让，流程见下面的leader转让流程）</li>
<li>判断当前是否在租约期以内，判断的条件包括：checkQuorum为true，当前节点保存的leader不为空，没有到选举超时，前面这三个条件同时满足。</li>
<li>如果不是强制要求选举，同时又在租约期以内，那么就忽略该选举消息返回不进行处理，这么做是为了避免出现那些离开集群的节点，频繁发起新的选举请求（见论文4.2.3）。</li>
</ol>
</li>
<li>如果不是前面的忽略选举消息的情况，那么除非是prevote类的选举消息，在收到其他消息的情况下，该节点都切换为follower状态。</li>
<li>此时需要针对投票类型中带来的其他字段进行处理了，需要同时满足以下两个条件：<ol>
<li>只有在没有给其他节点进行过投票，或者消息的term任期号大于当前节点的任期号，或者之前的投票给的就是这个发出消息的节点</li>
<li>进行选举的节点，它的日志是更新的，条件为：logterm比本节点最新日志的任期号大，在两者相同的情况下，消息的index大于等于当前节点最新日志的index，即总要保证该选举节点的日志比自己的大。</li>
<li>只有在同时满足以上两个条件的情况下，才能同意该节点的选举，否则都会被拒绝。这么做的原因是：保证最后能胜出来当新的leader的节点，它上面的日志都是最新的。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="6-集群成员变化流程"><a href="#6-集群成员变化流程" class="headerlink" title="6. 集群成员变化流程"></a><p id="p6">6. 集群成员变化流程</p></h2><p>大原则是<font color="red">不能同时进行两个以上的成员变更</font>，因为同时进行两个以上的成员变更，可能会出现集群中有两个leader即导致了集群分裂的情况出现。</p>
<p>成员变化分为以下几种情况：成员删减、leader转让，下面分开讲解。</p>
<h3 id="6-1-一般的成员删减"><a href="#6-1-一般的成员删减" class="headerlink" title="6.1 一般的成员删减"></a><p id="p6_1">6.1 一般的成员删减</p></h3><p>成员变化操作做为日志的特殊类型，当可以进行commit的情况下，各个节点拿出该消息进行节点内部的成员删减操作。</p>
<hr>
<h3 id="6-2-leader-转让"><a href="#6-2-leader-转让" class="headerlink" title="6.2 leader 转让"></a><p id="p6_2">6.2 leader 转让</p></h3><ul>
<li>旧leader在接收到转让leader消息之后，会做如下的判断： <ul>
<li>a. 如果新的leader上的日志，已经跟当前leader上的日志同步了，那么发送timeout消息。 </li>
<li>b. 否则继续发append消息到新的leader上，目的为了让其能够与旧leader日志同步。</li>
</ul>
</li>
<li>当旧leader处于转让leader状态时，将停止接收新的prop消息，这样就避免出现在转让过程中新旧leader一直日志不能同步的情况。</li>
<li>当旧leader收到append消息应答时，如果当前处于leader转让状态，那么会判断新的leader日志是否已经与当前leader同步，如果是将发送timeout消息。</li>
<li>新的leader当收到timeout消息时，将使用context为campaignTransfer的选举消息发起新一轮选举，当context为该类型时，此时的选举是强制进行的。</li>
</ul>
<hr>
<h2 id="7-如何做到线性一致性"><a href="#7-如何做到线性一致性" class="headerlink" title="7. 如何做到线性一致性"></a><p id="p7">7. 如何做到线性一致性</p></h2><p>线性一致性（Linearizable Read）通俗来讲，就是保证读到最新的且已经commit的数据，不会读到老数据。</p>
<p>由于所有的leader和follower都能处理客户端的读请求，所以存在可能造成返回读出的旧数据的情况：</p>
<ul>
<li>leader和follower之间存在状态差，因为follower总是由leader同步过去的，可能会返回同步之前的数据。</li>
<li>如果发生了网络分区，某个leader实际上已经被隔离出了集群之外，但是该leader并不知道，如果还继续响应客户端的读请求，也可能会返回旧的数据。</li>
</ul>
<p>因此，在接收到客户端的读请求时，需要保证返回的数据都是当前最新的。</p>
<h4 id="ReadOnlySafe方式"><a href="#ReadOnlySafe方式" class="headerlink" title="ReadOnlySafe方式"></a>ReadOnlySafe方式</h4><p>leader在接收到读请求时，需要向集群中的超半数server确认自己仍然是当前的leader，这样它返回的就是最新的数据。</p>
<p>在etcd-raft中，为了实现 ReadOnlySafe，有如下的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadState <span class="keyword">struct</span> &#123;</span><br><span class="line">  Index <span class="keyword">uint64</span></span><br><span class="line">  RequestCtx []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>Index：接收到该读请求时，当前节点的commit索引。</li>
<li>RequestCtx：客户端读请求的唯一标识。<br>ReadState结构体用于保存读请求到来时的节点状态。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readIndexStatus <span class="keyword">struct</span> &#123;</span><br><span class="line"> req pb.Message</span><br><span class="line"> index <span class="keyword">uint64</span></span><br><span class="line"> acks <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readIndexStatus 数据结构用于追踪leader向follower发送的心跳信息，其中：</p>
<ul>
<li>req：保存原始的 readIndex 请求。</li>
<li>index：leader当前的commit日志索引。</li>
<li>acks：存放该 readIndex 请求有哪些节点进行了应答，当超过半数应答时，leader就可以确认自己还是当前集群的leader。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">option ReadOnlyOption</span><br><span class="line">pendingReadIndex <span class="keyword">map</span>[<span class="keyword">string</span>]*readIndexStatus</span><br><span class="line">readIndexQueue []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readOnly用于管理全局的readIndx数据，其中：</p>
<ul>
<li>option：readOnly选项。</li>
<li>pendingReadIndex：当前所有待处理的readIndex请求，其中key为客户端读请求的唯一标识。</li>
<li>readIndexQueue：保存所有readIndex请求的请求唯一标识数组。</li>
</ul>
<p>以上是对数据结构的介绍，接下来是对流程的介绍：</p>
<ol>
<li>server收到客户端的读请求，此时会调用 raft.ReadIndex 函数发起一个 MsgReadIndex 的请求，带上的参数是客户端读请求的唯一标识（此时可以对照前面分析的MsgReadIndex及其对应应答消息的格式）。</li>
<li>follower将向leader直接转发 MsgReadIndex 消息，而leader收到不论是本节点还是由其他server发来的 MsgReadIndex 消息，其处理都是：<ul>
<li>首先如果该leader在成为新的leader之后没有提交过任何值，那么会直接返回不做处理。</li>
<li>调用 r.readOnly.addRequest(r.raftLog.committed, m) 保存该 MsgreadIndex 请求到来时的commit索引。</li>
<li>r.bcastHeartbeatWithCtx(m.Entries[0].Data)，向集群中所有其他节点广播一个心跳消息 MsgHeartbeat，并且在其中带上该读请求的唯一标识。</li>
<li>follower在收到leader发送过来的 MsgHeartbeat，将应答 MsgHeartbeatResp 消息，并且如果 MsgHeartbeat 消息中有ctx数据，MsgHeartbeatResp 消息将原样返回这个ctx数据。</li>
<li>leader在接收到 MsgHeartbeatResp 消息后，如果其中有ctx字段，说明该 MsgHeartbeatResp 消息对应的 MsgHeartbeat 消息，是收到 ReadIndex 时leader消息为了确认自己还是集群leader发送的心跳消息。首先会调用 r.readOnly.recvAck(m) 函数，根据消息中的ctx字段，到全局的 pendingReadIndex 中查找是否有保存该ctx的带处理的readIndex请求，如果有就在acks map中记录下该follower已经进行了应答。</li>
<li>当ack数量超过了集群半数时，意味着该leader仍然还是集群的leader，此时调用 r.readOnly.advance(m) 函数，将该 readIndex 之前的所有 readIndex 请求都认为是已经成功进行确认的了，所有成功确认的 readIndex 请求，将会加入到 readStates 数组中，同时leader也会向follower发送 MsgReadIndexResp。</li>
<li>follower收到 MsgReadIndexResp 消息时，同样也会更新自己的 readStates 数组信息。</li>
<li>readStates数组的信息，将做为ready结构体的信息更新给上层的raft协议库的使用者。</li>
</ul>
</li>
</ol>
<p>补充一点，在处理读请求时，实际上leader需要确保当前自己是不是leader、该读请求对应的commit索引是否得到了半数投票，而当一个节点刚成为leader的时候，如果没有提交过任何数据，那么在它所在的这个任期（term）内的commit索引当时是并不知道的，因此在成为leader之后，需要马上提交一个 no-op 的空日志，这样拿到该任期的第一个commit索引。</p>
<p><img src="/msgreadindex.png" alt="msgreadindex"></p>
<p>上图中，在leader收到 MsgReadIndex 后：</p>
<ul>
<li>向readOnly中添加与这次请求ctx相关的数据：<ul>
<li>向pendingReadIndex中添加以ctx为key的readIndexStatus，其中保存了当前的commitIndex、原始的MsgReadIndex消息、以及用于存放有哪些节点应答了该消息的acks数组。</li>
<li>向readIndexQueue数组中添加ctx。</li>
</ul>
</li>
<li>leader向集群中其他节点广播 MsgHeartbeat 消息，其中带上这次 MsgReadIndex 的ctx。</li>
</ul>
<p>在这之后，follower应答leader的MsgHeartbeat消息，如果消息中存在ctx字段都会带上应答，于是leader中的处理：</p>
<ul>
<li>收到 MsgHeartbeatResp 消息之后，如果发现其中有ctx，就去计算应答有没有超过半数，没有超过半数则返回。</li>
<li>走到这里就是超过半数应答了，此时拿到新的 readIndexStatus 数组。</li>
<li>遍历前面拿到的 readIndexStatus 数组，生成新的readStates数组。</li>
<li>放到Ready中下一次给客户端。</li>
</ul>
<p>总结一下，分为四步：</p>
<ol>
<li>leader检查自己在当前任期有没有commit过一条entry，没有提交过则不允许处理readIndex请求。</li>
<li>leader记录下来收到readIndex请求时候的commit index，然后leader向集群中所有节点发心跳广播，其中带上readIndex相关的ctx字段。</li>
<li>当超过半数的节点应答了第二部的心跳消息，说明此时leader还是集群的leader。</li>
<li>生成新的readStates数组放入Ready结构体中，等待下一次客户端来获取该数据。</li>
</ol>
<hr>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a><p id="p8">8. 其他</p></h2><h3 id="8-1-节点的几种状态"><a href="#8-1-节点的几种状态" class="headerlink" title="8.1 节点的几种状态"></a><p id="p8_1">8.1 节点的几种状态</p></h3><p>一个节点在leader上保存的状态有:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ProgressStateProbe ProgressStateType = <span class="literal">iota</span></span><br><span class="line">    ProgressStateReplicate</span><br><span class="line">    ProgressStateSnapshot</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>以下来分开解释这几种状态。</p>
<h4 id="探测状态：ProgressStateProbe"><a href="#探测状态：ProgressStateProbe" class="headerlink" title="探测状态：ProgressStateProbe"></a>探测状态：ProgressStateProbe</h4><p>探测状态，当节点拒绝了最近的append消息时，那么就会进入探测状态，此时leader会试图继续往前追述该节点的日志从哪里开始丢失的，让该节点的日志能跟leader同步上。在probe状态时，只能向它发送一次append消息，此后除非状态发生变化，否则就暂停向该节点发送新的append消息了。</p>
<p>只有在以下情况出现时才会恢复取消暂停状态（调用Progress的resume函数）：</p>
<ul>
<li>收到该节点的心跳消息。</li>
<li>该节点成功应答了前面的最后一条append消息。</li>
</ul>
<p>至于Probe状态，只有在该节点成功应答了Append消息之后，在leader上保存的索引值发生了变化，才会修改其状态切换到Replicate状态。</p>
<h4 id="接收数据状态：ProgressStateReplicate"><a href="#接收数据状态：ProgressStateReplicate" class="headerlink" title="接收数据状态：ProgressStateReplicate"></a>接收数据状态：ProgressStateReplicate</h4><p>正常接收副本数据的状态，当处于该状态时，leader在发送副本消息之后，就修改该节点的next索引为发送消息的最大索引+1。</p>
<h4 id="接收快照状态：jieshouProgressStateSnapshot"><a href="#接收快照状态：jieshouProgressStateSnapshot" class="headerlink" title="接收快照状态：jieshouProgressStateSnapshot"></a>接收快照状态：jieshouProgressStateSnapshot</h4><p>接收快照状态。 当leader向某个follower发送append消息，试图让该follower状态跟上leader时，发现此时leader上保存的索引数据已经对不上了，比如leader在index为10之前的数据都已经写入快照中了，但是该follower需要的是10之前的数据，此时就会切换到该状态下，发送快照给该follower。</p>
<p>因为快照数据可能很多，不知道会同步多久，所以单独把这个状态抽象出来。当快照数据同步追上之后，并不是直接切换到Replicate状态，而是首先切换到Probe状态。</p>
<hr>
<h3 id="8-2-Progress-上的数据索引"><a href="#8-2-Progress-上的数据索引" class="headerlink" title="8.2 Progress 上的数据索引"></a><p id="p8_2">8.2 Progress 上的数据索引</p></h3><p>Progress 结构体中有两个保存该follower节点日志索引的数据，其中：</p>
<ul>
<li>Next：保存下一次leader发送append消息给该follower时的日志索引。</li>
<li>Match：保存该follower节点上的最大日志索引。</li>
</ul>
<p>正常情况下，Next == Match + 1，即Next总是节点当前保存最大日志索引的下一条索引。但有两种情况除外：</p>
<ul>
<li>接收快照状态：此时Next = max(pr.Match+1, pendingSnapshot+1)</li>
<li>当该follower不在Replicate状态时，说明不是正常的接收副本状态。此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现。</li>
</ul>
<p><img src="/2022/01/15/etcd-Raft%E5%BA%93%E8%A7%A3%E6%9E%90/next-match.png" alt="next-match"></p>
<p>如上图所示，follower节点s1上最大日志索引为2，即Match = 2，Next = 3。 但是，由于新选出来的leader s2，其最大日志索引为3，此时s3需要同步日志到s1上，发现s1上的日志与自己的不匹配，所以会一直找到两者最开始匹配的索引位置，即最终找到索引1，因此最终保存s1的Next索引为1，而Match还是2（此时还没有修改s1上的日志）。当最终s1上的数据与s2同步时，此时Next = 4，Match=3。</p>
<hr>
<h3 id="8-3-流量控制"><a href="#8-3-流量控制" class="headerlink" title="8.3 流量控制"></a><p id="p8_3">8.3 流量控制</p></h3><p>Progress结构体中，使用另一个 inflights 的数据结构用于流量控制。 该结构体使用一个固定大小的循环缓冲区来控制给一个节点同步数据的流量控制，每当给该follower发送同步消息时，就占用该缓冲区的一个空间；反之，当收到该follower的成功接收了该同步消息的应答之后，就释放缓冲区的空间。</p>
<p>当该缓冲区数据饱和时，将暂停继续同步数据到该follower。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>etcd Raft库解析</p><p><a href="https://lameber1123.github.io/2022/01/15/etcd-Raft库解析/">https://lameber1123.github.io/2022/01/15/etcd-Raft库解析/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Lamber</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-01-15</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Raft/">Raft</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="link-muted mr-2" rel="tag" href="/tags/etcd/">etcd</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/19/%E4%BD%BF%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用etcd实现存储服务</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/01/15/Raft%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"><span class="level-item">Raft算法原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Lamber"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Lamber</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lamber1123" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lamber1123"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/167431968"><i class="iconfont icon-bilibili-fill"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/6859290371"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/lamber-51"><i class="iconfont icon-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeiChat" href="/img/weixin.png"><i class="fab fa-weixin"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://Nancy0205.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Nancy的博客</span></span><span class="level-right"><span class="level-item tag">nancy0205.github.io</span></span></a></li><li><a class="level is-mobile" href="https://ecampus.nwpu.edu.cn/main.html#/Index" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">翱翔门户</span></span><span class="level-right"><span class="level-item tag">ecampus.nwpu.edu.cn</span></span></a></li><li><a class="level is-mobile" href="https://cnki.net/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">中国知网</span></span><span class="level-right"><span class="level-item tag">cnki.net</span></span></a></li><li><a class="level is-mobile" href="https://docs.pingcap.com/zh/tidb/stable/tikv-overview/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">PingCAP</span></span><span class="level-right"><span class="level-item tag">docs.pingcap.com</span></span></a></li><li><a class="level is-mobile" href="https://hardcore.feishu.cn/docs/doccnMRVFcMWn1zsEYBrbsDf8De#" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Raft讲稿</span></span><span class="level-right"><span class="level-item tag">hardcore.feishu.cn</span></span></a></li><li><a class="level is-mobile" href="https://liqul.github.io/blog/tags/Raft/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bucket&amp;Hammer</span></span><span class="level-right"><span class="level-item tag">liqul.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.codedump.info/post/20180922-etcd-raft/#%E8%BE%93%E5%85%A5%E5%8F%8A%E8%BE%93%E5%87%BA" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Raft源码解析</span></span><span class="level-right"><span class="level-item tag">www.codedump.info</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/opengauss/openGauss-server/blob/master/README.md" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">openGauss官方文档</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CentOS/"><span class="level-start"><span class="level-item">CentOS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Raft%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">Raft笔记</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/TiKV%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">TiKV笔记</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/css%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">css笔记</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/html%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">html笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/icarus/"><span class="level-start"><span class="level-item">icarus</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/js%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">js笔记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/openGauss/"><span class="level-start"><span class="level-item">openGauss</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%91%B8%E9%B1%BC/"><span class="level-start"><span class="level-item">摸鱼</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-07T11:56:58.000Z">2022-12-07</time></p><p class="title"><a href="/2022/12/07/DCFTest%EF%BC%9ADCF%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/">DCFTest：DCF框架的测试工具</a></p><p class="categories"><a href="/categories/openGauss/">openGauss</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-17T07:59:47.000Z">2022-10-17</time></p><p class="title"><a href="/2022/10/17/%E8%85%BE%E8%AE%AF%E5%8F%AE%E5%BD%93%E9%9F%B3%E7%AE%B1%E5%88%B7%E5%85%A5Android8-1%E7%B3%BB%E7%BB%9F/">腾讯叮当音箱刷入Android8.1系统</a></p><p class="categories"><a href="/categories/%E6%91%B8%E9%B1%BC/">摸鱼</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T12:22:28.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%90%AF%E5%8A%A8OG%E7%9A%84DCF%E6%A8%A1%E5%9D%97/">服务器上启动OG的DCF模块</a></p><p class="categories"><a href="/categories/openGauss/">openGauss</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-06T13:52:30.000Z">2022-05-06</time></p><p class="title"><a href="/2022/05/06/openGauss%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/">openGauss存储技术</a></p><p class="categories"><a href="/categories/openGauss/">openGauss</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-18T08:20:22.000Z">2022-04-18</time></p><p class="title"><a href="/2022/04/18/openGauss%E7%9A%84DCF%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/">openGauss的DCF组件详解</a></p><p class="categories"><a href="/categories/openGauss/">openGauss</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CentOS/"><span class="tag">CentOS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DCF/"><span class="tag">DCF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DCFTest/"><span class="tag">DCFTest</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Key-Value/"><span class="tag">Key-Value</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MVCC/"><span class="tag">MVCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PD/"><span class="tag">PD</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paxos/"><span class="tag">Paxos</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RPC/"><span class="tag">RPC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raft/"><span class="tag">Raft</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Region/"><span class="tag">Region</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RocksDB/"><span class="tag">RocksDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TiDB/"><span class="tag">TiDB</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TiFlash/"><span class="tag">TiFlash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TiKV/"><span class="tag">TiKV</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VMware/"><span class="tag">VMware</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zab/"><span class="tag">Zab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/icarus/"><span class="tag">icarus</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ico/"><span class="tag">ico</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openGauss/"><span class="tag">openGauss</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%83%E4%BF%A1%E6%81%AF/"><span class="tag">元信息</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"><span class="tag">映射关系</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Lamber&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Lamber</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/6859290371"><i class="fab fa-weibo"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="WeiChat" href="/img/weixin.png"><i class="fab fa-weixin"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/lamber1123"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>